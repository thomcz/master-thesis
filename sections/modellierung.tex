%% LaTeX2e class for student theses
%% sections/evaluation.tex
%% 
%% Karlsruhe Institute of Technology
%% Institute for Program Structures and Data Organization
%% Chair for Software Design and Quality (SDQ)
%%
%% Dr.-Ing. Erik Burger
%% burger@kit.edu
%%
%% Version 1.3.3, 2018-04-17

\chapter{Modellierung}
\label{ch:modellierung}
Im Folgenden soll zunaechst untersucht werden ob und wie eine konkrete MOM in Palladio modelliert werden kann und an welchen Stellen die Modellierung an ihre Grenzen kommt. Im Anschluss werden Ansätze vorgestellt, mit denen diese Probleme versucht wurden zu beheben.

%Warum sinnvoll eine MOM explizit zu modellieren? \\
%- eroeffnet neue Moeglichkeiten \\
%- bestimmte effekte mit bisheriger modellierung nicht moeglich\\
\section{Anforderungserhebung}
Aus Definition von MOMs (siehe Grundlagen) und den Messungen aus (siehe Benchmarks) wurden Anforderungen an eine Modellierung spezifiziert. \\
Was soll eine MOm koenen?\\
Asynchron Nachricht senden \\
Asynchron Nachricht empfangen \\
bestimmte Topics/Queues\\
Eingaben durch benutzer: \\
Groesse der Nachrichten angeben (siehe Benchmarks einfluss auf Latenz)\\
Anzahl der Nachrichten angeben \\
Angabe des Durchsatzes \\
Ausgabe: \\
Queue verhalten \\
Antwortzeit/Latenz der Nachrichten \\

Wie bereits in Grundlagen beschrieben gibt es fuer PCM die moeglichkeit eine MOM zu modellieren (Integration Event Based Communication)\\
- Problem:  \\
-- Kommunikation nur in eine Richtung \\
-- kein abholen von Nachrichten moeglich \\
-- kein Modellieren von Queues moeglich (aquire/release \\
-- nur RDs in verschiedenen Verarbeitungsschritten angeben auf dem Weg zum Ziel \\
Im Folgenden soll beschrieben werden, wie ein Modell aussehen soll, das eine MOM abbildet und die Anforderungen erfüllt. \\

Das Ziel ist es eine allgemeine MOM Modellierung zu erstellen, die das Verhalten einer MOM abbilden kann. Dabei soll nicht Wert auf ein spezielles Verhalten gelegt werden. Stattdessen soll es moeglich sein die Modellierung um Konfigurationen, wie zum Beispiel RMQs lazy Queues, erweitern zu koennen. 

\section{Modell}
Ziel: Modellierung mit bestehenden Elementen.\\
Anhand der bekannten MOM Architekturen aus der Untersuchung verschiedener MOMs wurde versucht zu definieren wie eine MOM modelliert werden kann. Dabei wurden die Anforderungen versucht umzusetzen. \\
- 2 Moeglichkeiten entweder mit oder ohne Exchange explizit zu modellieren.\\
- Vorteil Explizit: RDs fuer verteilung (konnte aber nicht ausgemessen werden) \\
- Nachrichten Typen mitschicken (fanout, direct) und in Branches auswerten

\subsection{Repository}
Die untersuchten Architekturen hatten als Gemeinsamkeit einen Verteiler (Exchange) und eine Warteschlange. \\

Modellierung von einem Exchange als BC und einer Queue als BC mit passiver Ressource \autoref{img:mom_repository} \\

Exchange verteilt Msgs\\

Queues wurden als Passive Ressource modelliert. Ein Aquire wurde als Consume und ein Release als Produce interpretiert. Dieser Ansatz ermöglicht es jedoch nicht einzelne Nachrichten durch das System zu verfolgen. \\

Exchange required eine Queue. a ein exchange mehrere Queues haben kann muss ein Exchange auch mehrere Queues requiren. Ausserdem muss er entscheiden koennen an welche Queue er senden oder von welcher er nachrichten empfaengt. Dies soll mithilfe von guarded branches gemacht werden. Fuer jede angeschlossene Queue gibt es einen branch. Nachricht hat bytesize und nen Type anhand dessen sie in eine Queue kommt. Oder Empfaenger sagt, wie viel Byte er aus einer bestimmten Queue heraus nehmen moechte. \\

\begin{figure}
\center
  \includegraphics[width=1\textwidth]{images/mom_repository.png}
  \caption{Repository einer MOM mit Exchange und Warteschlange}
  \label{img:mom_repository}
\end{figure}

\subsection{System}
Im System werden Queues mit dem Exchange \autoref{img:mom_system}\\
Sender und Empfaenger werden jeweils an den Exchange angeschlossen. Fuer Senden und Empfangen jeweils eine Porivided Role.

\begin{figure}
\center
  \includegraphics[width=1\textwidth]{images/mom_system.png}
  \caption{Systemmodell mit einer MOM und einem Sender und Empfänger}
  \label{img:mom_system}
\end{figure}

\subsection{Usage}
Benutzer gibt an ob er empfangen oder senden will. \\
Benutzer gibt an welche Queue/Topic er wie viel Byte senden/empfangen moechte. \\
Ankunftsrate als Hebel um Sende-Empfangrate abzubilden \\
\subsection{Ressource Environment und Allokation}
Einen Server fuer Exchange \\
Jede Queue kann auf anderer Ressource deployed sein. die am Ende mit dem Exchange Server verbunden sein muss.\\
Fuer LR kann RD angegeben werden.

\section{Ressource Demands}
\subsection{RMQ}
\label{sec:rmqRd}
Fuer RDs wurden die Messungen aus (Benchmarks) herangezogen. \\ 
Das Ziel ist, dass der Benutzer keinen MOM spezifischen RD angeben muss. \\
In \autoref{sec:maxthroughput} wurde gemessen, was die moegliche Datenmenge ist, die gesendet werden kann (Durchsatz). Dieser Wert wird im Ressource Environment in die jeweiligen Linking Ressources eingetragen. Dabei wird fuer den LR zwischen Sender und MOM der Wert fuer keine Empfaenger eingetragen und fuer die LR zwischen Empfaenger und MOM der Wert fuer mit Empfaenger. \\

Latenz einer Nachricht mit verschiedener Bytegroesse wurde ausgemessen (siehe latenz verschiedenen Msg größen). Mithilfe einer Regressionsanalyse konnte ein RD der Form (7 * (msg.BYTESIZE + 110588)) / 489 identifiziert werden.\\

Wo Nachrichten hingeschrieben wurden waren auch ein wichtiger Einflussfaktor. Fuer eine Nachricht der Groesse x konnte ein RD der Form e * x / 1000 identifiziert werden. Dieser wurde aus der Differenz der Messungen mit und ohne LazyQueues errechnet. \\

Falls die Netzwerklatenz betrachtet werden soll, kann diese in der jeweiligen LR eingetragen werden.\\

Als Eingabe fuer das System soll im Usage Modell die zu sendende Nachrichtengroesse mithilfe einer UsageVariable und der Characteristic: Bytesize angegeben werden.\\

Die Anzahl an Nachrichten die gesendet oder empfangen werden koennen werden ueber die Ankuftzeit gesteuert.\\
ArrivalTime / Anzahl Msgs \\
oder einfach BYTESIZE = Bytesize * Anazahl Nachrichten \\

- TODO: tabelle mit Werten fuer alle RDs\\

Somit sollte sich fuer die Response Time folgendes ergeben: Response Time: ByteSize / Throughput + RD / CPU + Latency + HddRD/HDD \\
%RD an Aquire um Latenz abzubilden

%Als erstes sollte die Sende und Empfangsrate abgebildet werden. Beobachtet man (ref zu Messung verschiedene Senderaten) bemerkt man fuer die ersten Messungen, solange Warteschlange nicht allzu voll wird, einen linearen Anstieg der Latenz. Daraus laesst sich zunaechst folgender RD ableiten:






%Latenz: Unter Latenz versteht man im MOM Kontext, die Zeit, die eine einzelne Nachricht braucht um beim Consumer anzukommen. Da jede Nachricht einen Zeitstempel bekommt kann die Zeit gemessen werden, wenn sie aus der Warteschlange entnommen wurde.

%welche Effekte koennen wir so hoffentlich abbilden
\subsection{Kafka}

\section{Untersuchung der MOM Bausteine}
In diesem Abschnitt sollen die Bausteine in bestimmten Szenarien ueberprueft werden. Dabei sollen die Simulations- und Messergebnisse aus \autoref{sec:mom} verglichen werden.
\subsection{RMQ}
Im Folgenden betrachten wir das in (Abb) abgebildete Szenario. Darin befindet sich ein Sender und ein Empfaenger. Der Sender sendet pro Zeiteinheit und der Empfaenger empfaengt pro Zeiteinheit eine bestimmte Menge an Daten. Dieses Szenario soll den Benchmark widerspiegeln, der fuer das ausmessen von RMQ in \autoref{sec:rmqBenchmark} verwendet wurde.




\subsubsection{Simulation 1} 
\label{sec:rmqSimulation1}
In der ersten Simulation betrachten wir den Fall, dass Sender und Empfaenger die gleichen Ankunftszeiten haben. Die gesendete Nachrichten haben die groessen 100, 200, 300, 400, 500 und 1000 Kbyte. Verglichen wurde mit den Messungen aus \autoref{sec:oneMsgLatency}. Der Sender, Empfaenger und der Broker befinden sich jeweils auf der selben Maschine. Betrachtet wurden der Fuellstand der Warteschlange und die Latenz der Nachrichten. 
%B
Da die Ankunftszeiten der beiden Akteure gleich sind, bleibt die Warteschlange die ganze Zeit ueber Leer. Die Ergebnisse der Latenz einer Nachricht sind in \autoref{img:simulation1} abgebildet. ...

\begin{figure}
\center
  \includegraphics[width=0.5\textwidth]{images/modelSimulationResults/simulation1.png}
  \caption{Latenz einer Nachricht mit verschiedenen Groessen (Modell vs. Real System)}
  \label{img:simulation1}
\end{figure}

\subsubsection{Simulation 2} 
Diese Simulation betrachtet zusaetzlich zu dem Fall aus Simulation 1 die Netzwerklatenz mit. Dazu sind Sender, Empfaenger und Broker auf unterschiedlichen Maschinen. Die Nachrichten haben wieder die groessen 100, 200, 300, 400, 500 und 1000 Kbyte. Im Modell wurden fuer die LinkingRessources der Durchsatz und die Latenz, wie in \autoref{sec:rmqRd} beschrieben, angepasst. Die Messung mit der verglichen wurde ist in \autoref{sec:oneMsgLatency} beschrieben. Auch bei diesem Vergleich wurde der Fuellstand der Warteschlange und die Latenz der Nachrichten betrachtet. 
%B
Auch hier bleibt die Warteschlange leer, da die Ankuftszeiten der Sender und Empfaenger gleich sind. Die Latenz der Nachrichten ist in \autoref{img:simulation2} abgebildet. 
\begin{figure}
\center
  \includegraphics[width=0.5\textwidth]{images/modelSimulationResults/simulation2.png}
  \caption{Latenz einer Nachricht mit verschiedenen Groessen mit Netzwerklatenz (Modell vs. Real System)}
  \label{img:simulation2}
\end{figure}


\subsubsection{Simulation 3}
In dieser Simulation soll geprueft werden ob sich Modell und Real System bei unterschiedlichen Ankuftszeiten gleich verhalten. Dabei ist die Ankuftszeit des Senders jede Sekunde und die des Empfangers alle zwei Sekunde. Der Fuellstand der Warteschlange wird ueber die Zeit betrachtet. Verglichen wurde mit der Messung aus \autoref{sec:queueGrowth}.
%B
Die Ergebnisse sind in \autoref{img:simulation3} abgebildet. Dabei ist zu sehen, dass sich Messung und Simulation gleich verhalten und ueber die Zeit ansteigen.
\begin{figure}
\center
  \includegraphics[width=0.5\textwidth]{images/modelSimulationResults/simulation3.png}
  \caption{Anwachsen der Warteschlange (Modell vs. Real System)}
  \label{img:simulation3}
\end{figure}

\subsubsection{Simulation 4}
Bei der folgenden Simulation ist die Ankuftszeit des Senders jede Sekunde und die des Empfangers alle zwei Sekunden. Im Unterschied zur vorherigen Simulation gibt es einen weiterern Empfaenger, der auch jede zweite Sekunde ankommt. Ziel dieser Simulation soll sein, zu pruefen ob zwei Empfaenger die Warteschlange zusammen abarbeiten koennen, wie es auch im realen System ist, wie in \autoref{sec:varyingConsumer} beschriebenen.
%B
\autoref{img:simulation4} zeigt den Zustand der Warteschlange ueber die Zeit. Im Unterschied zu \autoref{img:simulation3}, bekommen die beiden Empfaenger die Warteschlange gemeinsam abgearbeitet.

\begin{figure}
\center
  \includegraphics[width=0.5\textwidth]{images/modelSimulationResults/simulation4.png}
  \caption{Gemeinsames Abarbeiten einer Warteschlange durch zwei Empfaenger (Modell)}
  \label{img:simulation4}
\end{figure}

%Simulation 5: \\
%- Max Durchsatz \\
%- eine Nachricht mit max Bytesize schicken \\
%-> Response time sollte kontinuirlich ansteigen \\


\subsubsection{Simulation 5}
Die letzte Simulation betrachtet den Fall von Lazy Warteschlangen in RMQ. Sender und Empfaenger haben die gleiche Ankunftszeiten und die gesendete Nachrichten haben die Groessen 100, 200, 300, 400, 500 und 1000 Kbyte. Der RD fuer eine Nachricht wurde erweitert. Dieser ist in \autoref{sec:rmqRd} beschrieben. Erwartet wird, dass die Latenz im Vergleich zu \autoref{sec:rmqSimulation1} ansteigt. Verglichen wurde mit der Messung aus \autoref{sec:rmqLazy}.
%B
Die Ergebnisse sind in \autoref{img:simulation6} abgebildet. Wie zu erwarten steigt die Latenz an. Im Vergelich zur realen Messung liegt der Unterschied bei x Prozent.
\begin{figure}
\center
  \includegraphics[width=0.5\textwidth]{images/modelSimulationResults/simulation6.png}
  \caption{Latenz einer Nachricht mit verschiedenen Groessen bei Lazy Warteschlangen (Modell vs. Real System)}
  \label{img:simulation6}
\end{figure}


\subsection{Kafka}

\section{Grenzen}
Dieser Ansatz ermöglicht es jedoch nicht einzelne Nachrichten durch das System zu verfolgen\\

welche Moeglichkeiten gibt es? Dominiks Queue Modell. Direkt drauf verweisen, oder eine/diese Idee beschreiben.\\
%Queue Fuellstand ist unbekannt \\

%Nachdem eine MOM in das Experimentsystem eingebaut wurde, soll sie im Anschluss in Palladio modelliert werden. Wie bereits erwähnt existiert eine Palladio Modellierung des Experimentsystem, auf der aufgebaut werden kann. Bei der Modellierung der MOM soll zunächst die Standardkonfiguration und in späteren Iterationen Parametrisierbarkeit modelliert werden. Dazu soll zunächst versucht werden die MOM mithilfe vorhandener PCM Elementen zu modellieren und Unzugänglichkeiten zu identifizieren. Die Idee ist, mithilfe von Architecture-Templates \cite{architcturetemplate} diese Unzugänglichkeiten zu beseitigen. Dabei handelt es sich um wiederverwendbare Muster, die auf Palladio-Modelle angewendet werden können. Beispielsweise kann anstelle der manuellen Modellierung eines Lastverteilers auch das Architectural-Template für Lastverteiler verwendet werden. %Da diese Anwendung nur aus wenigen kleinen Schritten besteht, können Architekten viel Modellierungsaufwand einsparen.


%(-- RabitMQ Config:)\\% https://www.rabbitmq.com/configure.html\\
%(-- Kafka Config:)\\ %https://kafka.apache.org/documentation/#brokerconfigs 

