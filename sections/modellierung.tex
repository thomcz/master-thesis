%% LaTeX2e class for student theses
%% sections/evaluation.tex
%% 
%% Karlsruhe Institute of Technology
%% Institute for Program Structures and Data Organization
%% Chair for Software Design and Quality (SDQ)
%%
%% Dr.-Ing. Erik Burger
%% burger@kit.edu
%%
%% Version 1.3.3, 2018-04-17

\chapter{Modellierung}
\label{ch:modellierung}
Im Folgenden soll zunaechst untersucht werden ob und wie eine konkrete MOM in Palladio modelliert werden kann und an welchen Stellen die Modellierung an ihre Grenzen kommt. Im Anschluss werden Ansätze vorgestellt, mit denen diese Probleme versucht wurden zu beheben.


%Anhand der bekannten MOM Architekturen aus der Untersuchung verschiedener MOMs wurde im ersten Schritt versucht zu definieren wie eine MOM aussehen soll. 
%wurde versucht die RMQ Architektur zu modellieren. (Abb beschreiebn). Queues wurden als Passive Ressource modelliert. Ein Aquire wurde als Consume und ein Release als Produce interpretiert. Dieser Ansatz ermöglicht es jedoch nicht einzelne Nachrichten durch das System zu verfolgen. Außerdem ist dieser Ansatz der expliziten Modellierung einer jeden Queue nicht praktikabel (zu viel Aufwand jede Queue zu modellieren).
%Modellierung mit bestehenden Elementen (1 Idee mit passive Ressouce)

%Wiederverwendung von Events -> Beschreibung von Events

%Beschreiben der neuen Queues?
%- Ansatz mit und ohne Queues

%Beschreibung der Modelle

%Beschreibung der ResourceDemands

%Beschreibung der Transformationen (evtl mit einweben von Effekten wie \#Queues = \#Cores)

%Vergleich Analyse und Benchmarks
\section{Integration Event Based Communication}
- Beschreibung des Mechanismus (Modell, Transformation) \\
- Problem:  \\
-- Kommunikation nur in eine Richtung \\
-- kein abholen von Nachrichten moeglich \\
-- kein Modellieren von Queues moeglich (aquire/release \\
Im Folgenden soll beschrieben werden, wie ein Modell aussehen soll, das eine MOM abbildet \\
\section{Modell}
Warum sinnvoll eine MOM explizit zu modellieren? \\
- eroeffnet neue Moeglichkeiten \\
- bestimmte effekte mit bisheriger modellierung nicht moeglich\\
Anhand der bekannten MOM Architekturen aus der Untersuchung verschiedener MOMs wurde im ersten Schritt versucht zu definieren wie eine MOM aussehen soll. Die untersuchten Architekturen hatten als Gemeinsamkeit einen Verteiler (Exchange) und eine Warteschlange. \\
Modellierung von einem Exchange und einer Queue mit passiver Ressource \\
Ziel ist es nicht ein spezielle Verhalten einer MOM zu modellieren, zum Beispiel lazy Queues, sondern das allgemeine Verhalten von MOMs in verschiedenen Szenarien modellieren zu koennen, bzw. das in spaeteren Arbeiten darauf aufgebaut werden kann.
\subsection{Repository}
Exchange verteilt Msgs

Queue als Passive Ressource -> kein verfolgen einzelnern Nachrichten durch das system

Aquire: empfangen
release: senden

\subsection{System}

\subsection{Usage}
Ankunftsrate als Hebel um Sende-Empfangrate abzubilden
\subsection{Ressource Environment und Allokation}
Einen Server fuer MOM

\section{Ressource Demands}
In \autoref{sec:maxthroughput} wurde gemessen, was die moegliche Datenmenge ist, die gesendet werden kann (Durchsatz). Dieser Wert wird im Ressource Environment in die jeweiligen Linking Ressources eingetragen. Dabei wird fuer den LR zwischen Sender und MOM der Wert fuer keine Empfaenger eingetragen und fuer die LR zwischen Empfaenger und MOM der Wert fuer mit Empfaenger. \\

Latenz einer Nachricht mit verschiedener Bytegroesse wurde ausgemessen (siehe latenz verschiedenen Msg größen). Mithilfe einer Regressionsanalyse konnte ein RD der Form (7 * (msg.BYTESIZE + 110588)) / 489 identifiziert werden.\\

Wo Nachrichten hingeschrieben wurden waren auch ein wichtiger Einflussfaktor. Deshalb wurde fuer RMQ fuer den Fall das Lazy Queues simuliert werden sollen ein RD der Form:... aus der Differenz der Messungen mit und ohne LazyQueues bestimmt. \\

Falls die Netzwerklatenz betrachtet werden soll, kann diese in der jeweiligen LR eingetragen werden.\\
- TODO: tabelle mit Werten fuer alle RDs

Als Eingabe fuer das System soll im Usage Modell die zu sendende Nachrichtengroesse mithilfe einer UsageVariable und der Characteristic: Bytesize angegeben werden.\\

Die Anzahl an Nachrichten die gesendet oder empfangen werden koennen werden ueber die Ankuftzeit gesteuert.\\
ArrivalTime / Anzahl Msgs \\
oder einfach BYTESIZE = Bytesize * Anazahl Nachrichten \\

%RD an Aquire um Latenz abzubilden

%Als erstes sollte die Sende und Empfangsrate abgebildet werden. Beobachtet man (ref zu Messung verschiedene Senderaten) bemerkt man fuer die ersten Messungen, solange Warteschlange nicht allzu voll wird, einen linearen Anstieg der Latenz. Daraus laesst sich zunaechst folgender RD ableiten:






%Latenz: Unter Latenz versteht man im MOM Kontext, die Zeit, die eine einzelne Nachricht braucht um beim Consumer anzukommen. Da jede Nachricht einen Zeitstempel bekommt kann die Zeit gemessen werden, wenn sie aus der Warteschlange entnommen wurde.

%welche Effekte koennen wir so hoffentlich abbilden

\section{Untersuchung des MOM Bausteins}
Uerberpruefe ob die Simulation des Modells mit Benchmark Messung passen.\\

Einfaches Szenario: Sender/Empfaenger, einer sendet, einer empfaengt.\\

Response Time: ByteSize / Throughput + RD / CPU + Latency + HddRD/HDD \\

Simulation 1: \\
Ankunftszeiten gleich \\
Bytesize sind zwische 100 und 10000 \\
Queue sollte immer leer sein, weil Nachricht gleich raus genommen \\
Vergleich mit echten Messungen \\
- RespnseTime \\
- Queue verhalten \\

Simulation 2: \\
- Simulation 1, aber diesmal mit Latenz (bei Linking Ressouce)\\

Simulation 3: \\
- unterschiedliche Ankuftszeiten Sender 0.5 und Empfaenger 1 \\
-> Ansteigen der Queue \\

Simulation 4: \\
Wie simulation 3, aber jetzt weiterer Empfaenger mit gleicher Ankunftszeit \\
-> Queue wieder leer\\

Simulation 5: \\
- Max Durchsatz \\
- eine Nachricht mit max Bytesize schicken \\
-> Response time sollte kontinuirlich ansteigen \\


Simulation 6: \\
- lazyqueues \\
- HDD RD hinzufuegen \\
-> Response time sollte ansteigen \\



%Die Nachrichtenmenge sollen ueber die Ankunftsrate des Senders und Empfaengers geregelt werden. Die Idee ist, dass es keinen Unterschied macht ob ein sender pro Zeiteinheit 1000 Nachrichten verschickt oder pro Zeiteinheit 1000 mal Ankommt und jeweils eine Nachricht verschickt. Sommit erhalten wir fuer Sende- und Empfangsrate die Formel: 1 / Senderate.



\section{Grenzen}
Dieser Ansatz ermöglicht es jedoch nicht einzelne Nachrichten durch das System zu verfolgen\\

welche Moeglichkeiten gibt es? Dominiks Queue Modell. Direkt drauf verweisen, oder eine/diese Idee beschreiben.\\
%Queue Fuellstand ist unbekannt \\

%Nachdem eine MOM in das Experimentsystem eingebaut wurde, soll sie im Anschluss in Palladio modelliert werden. Wie bereits erwähnt existiert eine Palladio Modellierung des Experimentsystem, auf der aufgebaut werden kann. Bei der Modellierung der MOM soll zunächst die Standardkonfiguration und in späteren Iterationen Parametrisierbarkeit modelliert werden. Dazu soll zunächst versucht werden die MOM mithilfe vorhandener PCM Elementen zu modellieren und Unzugänglichkeiten zu identifizieren. Die Idee ist, mithilfe von Architecture-Templates \cite{architcturetemplate} diese Unzugänglichkeiten zu beseitigen. Dabei handelt es sich um wiederverwendbare Muster, die auf Palladio-Modelle angewendet werden können. Beispielsweise kann anstelle der manuellen Modellierung eines Lastverteilers auch das Architectural-Template für Lastverteiler verwendet werden. %Da diese Anwendung nur aus wenigen kleinen Schritten besteht, können Architekten viel Modellierungsaufwand einsparen.


%(-- RabitMQ Config:)\\% https://www.rabbitmq.com/configure.html\\
%(-- Kafka Config:)\\ %https://kafka.apache.org/documentation/#brokerconfigs 

